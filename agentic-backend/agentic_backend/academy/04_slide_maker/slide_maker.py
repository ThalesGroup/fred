# agentic_backend/core/agents/slide_maker.py
# -----------------------------------------------------------------------------
# üí° ACADEMY AGENT: SLIDE MAKER üí°
# This agent demonstrates two key patterns for asset generation:
# 1. Using the LLM to generate content (Node: plan_node).
# 2. Rendering that content into a binary file (.pptx) and uploading it to secure storage (Node: render_node).
# 3. Returning a **structured message** (LinkPart) for client-side download rendering.
# -----------------------------------------------------------------------------

from __future__ import annotations

import logging
import tempfile
from pathlib import Path
from typing import List, Optional, TypedDict

from langchain_core.messages import AIMessage, AnyMessage
from langgraph.graph import END, START, StateGraph
from langgraph.graph.message import add_messages
from pptx import Presentation
from pptx.util import Pt
from typing_extensions import Annotated

from agentic_backend.application_context import get_default_chat_model
from agentic_backend.common.kf_agent_asset_client import AssetRetrievalError
from agentic_backend.core.agents.agent_flow import AgentFlow
from agentic_backend.core.agents.agent_spec import AgentTuning, FieldSpec, UIHints
from agentic_backend.core.agents.runtime_context import RuntimeContext
from agentic_backend.core.chatbot.chat_schema import (
    LinkKind,
    LinkPart,
    MessagePart,
    TextPart,
)
from agentic_backend.core.runtime_source import expose_runtime_source

logger = logging.getLogger(__name__)

# --- Configuration & Tuning ---
# ------------------------------
TUNING = AgentTuning(
    role="slide_maker",
    description="An agent that generates PowerPoint slides with LLM content and provides a download link.",
    tags=["academy"],
    fields=[
        FieldSpec(
            key="ppt.template_key",
            type="text",
            title="PowerPoint Template Key",
            description="Agent asset key for the .pptx template.",
            ui=UIHints(group="PowerPoint"),
            default="simple_template.pptx",
        ),
        FieldSpec(
            key="gen.font_size_pt",
            type="number",
            title="Font Size (pt)",
            description="Font size applied to the inserted text.",
            default=14,
            ui=UIHints(group="PowerPoint"),
        ),
    ],
)


# --- Agent State ---
# -------------------
class SlideMakerState(TypedDict, total=False):
    """Minimal state: conversation messages and LLM output content."""

    messages: Annotated[List[AnyMessage], add_messages]
    content_slot: str  # Stores the text generated by plan_node


# --- Core Agent ---
# ------------------
@expose_runtime_source("agent.SlideMaker")
class SlideMaker(AgentFlow):
    """
    Simplified agent to generate a PowerPoint slide with LLM content
    and return a structured download link.
    """

    tuning = TUNING
    _graph: Optional[StateGraph] = None
    TARGET_PLACEHOLDER_INDEX = 1  # Hardcoded index for content insertion

    async def async_init(self, runtime_context: RuntimeContext):
        await super().async_init(runtime_context)
        self.model = get_default_chat_model()
        self._graph = self._build_graph()

    def _build_graph(self) -> StateGraph:
        """Sets up the two-node linear flow: plan -> render -> END."""
        g = StateGraph(SlideMakerState)
        g.add_node("plan_node", self.plan_node)
        g.add_node("render_node", self.render_node)
        g.add_edge(START, "plan_node")
        g.add_edge("plan_node", "render_node")
        g.add_edge("render_node", END)
        return g

    def _last_user_message_text(self, state: SlideMakerState) -> str:
        """Fetches the content of the most recent user message."""
        for msg in reversed(state.get("messages", [])):
            if getattr(msg, "type", "") in ("human", "user"):
                return str(getattr(msg, "content", "")).strip()
        return ""

    # --------------------------------------------------------------------------
    # Node 1: Plan Node (LLM Content Generation)
    # --------------------------------------------------------------------------
    async def plan_node(self, state: SlideMakerState) -> SlideMakerState:
        """Generates a concise text block from the LLM based on the user's request."""
        user_ask = self._last_user_message_text(state)

        system = (
            "You are a concise summarization expert. Your task is to provide a brief, "
            "professional, 5-sentence answer to the user's question, suitable for a "
            "single slide content block. Reply ONLY with the text content, "
            "no prefix, suffix, or formatting."
        )

        resp = await self.model.ainvoke(
            [
                {"role": "system", "content": system},
                {"role": "user", "content": f"Question: {user_ask}"},
            ]
        )

        text_content = str(getattr(resp, "content", "")).strip()
        return {"content_slot": text_content}  # type: ignore[typeddict-item]

    # --------------------------------------------------------------------------
    # Node 2: Render Node (Asset Generation, Upload, and Structured Response)
    # --------------------------------------------------------------------------
    async def render_node(self, state: SlideMakerState) -> SlideMakerState:
        """
        Fetches template, inserts LLM text, saves deck, uploads to storage,
        and returns a structured message with the download link.
        """
        template_path: Path | str = ""
        output_path: Optional[Path] = None
        text_content: str = state.get("content_slot", "")

        def _append_error(msg_content: str) -> SlideMakerState:
            logger.error("Error encountered: %s", msg_content)
            return {"messages": [AIMessage(content=msg_content)]}

        if not text_content:
            return _append_error("‚ùå Generation failed: LLM did not provide content.")

        try:
            # 1. Fetch template from secure asset storage
            template_key = (
                self.get_tuned_text("ppt.template_key") or "simple_template.pptx"
            )
            template_path = await self.fetch_asset_blob_to_tempfile(
                template_key, suffix=".pptx"
            )

            # 2. Render content into the PowerPoint template
            prs = Presentation(str(template_path))
            slide = prs.slides[0]

            try:
                placeholder = slide.placeholders[self.TARGET_PLACEHOLDER_INDEX]
            except IndexError:
                return _append_error(
                    f"‚ùå Rendering failed: Placeholder index {self.TARGET_PLACEHOLDER_INDEX} not found in the template."
                )

            if getattr(placeholder, "has_text_frame", False):
                tf = placeholder.text_frame  # type: ignore[attr-defined]
                tf.clear()
                p = tf.add_paragraph()
                p.text = text_content
                p.font.size = Pt(self.get_tuned_int("gen.font_size_pt", default=14))

            # 3. Save the modified presentation to a temp file
            with tempfile.NamedTemporaryFile(
                delete=False, suffix=".pptx", prefix="result_"
            ) as out:
                prs.save(out.name)
                output_path = Path(out.name)

            # 4. Upload the generated asset to user storage
            user_id_to_store_asset = self.get_end_user_id()
            final_key = f"{user_id_to_store_asset}_{output_path.name}"

            with open(output_path, "rb") as f_out:
                upload_result = await self.upload_user_asset(
                    key=final_key,
                    file_content=f_out,
                    filename=f"Generated_Slide_{self.get_name()}.pptx",
                    content_type="application/vnd.openxmlformats-officedocument.presentationml.presentation",
                    user_id_override=user_id_to_store_asset,
                )

            # 5. Construct the structured message for the UI
            final_download_url = self.get_asset_download_url(
                asset_key=upload_result.key, scope="user"
            )

            final_parts: list[MessagePart] = [
                TextPart(
                    text=f"‚úÖ **Success:** PowerPoint deck generated and securely saved to your assets.\n**Display Filename:** `{upload_result.file_name}`"
                ),
                LinkPart(
                    href=final_download_url,
                    title=f"Download {upload_result.file_name}",
                    kind=LinkKind.download,
                    mime="application/vnd.openxmlformats-officedocument.presentationml.presentation",
                ),
                TextPart(
                    text=(
                        f"\n---\n"
                        f"**üí° Academy Note (Structured Output Pattern)**\n"
                        f"The download button above is a **`LinkPart`** object (`kind='download'`).\n"
                        f"This pattern cleanly separates binary assets from text/Markdown in the UI.\n"
                        f"**Secure Header Required by UI:** `X-Asset-User-ID: {user_id_to_store_asset}`"
                    )
                ),
            ]

            # FINAL RETURN: Use structured parts in the AIMessage
            return {
                "messages": [AIMessage(content="", parts=final_parts)],
                "content_slot": state.get("content_slot", ""),
            }

        except AssetRetrievalError as e:
            return _append_error(
                f"‚ùå **Asset Error:** Cannot find template '{template_key}'. Check asset availability. (Details: {e})"
            )
        except Exception as e:
            # Catch all other exceptions during rendering/upload
            logger.exception("An unexpected error occurred during rendering/upload.")
            return _append_error(
                f"‚ùå **Processing Error:** Failed to generate/upload the slide. (Details: {e})"
            )

        finally:
            # 6. CRITICAL: Cleanup temporary files (template and output deck)
            if template_path:
                Path(template_path).unlink(missing_ok=True)
            if output_path and output_path.exists():
                output_path.unlink(missing_ok=True)
